"""
views/widgets.py
Widgets for ImageLab main window and tools
"""

from typing import Dict, Union
from PyQt5 import QtWidgets, QtCore, QtGui
import cv2

from uidesigns.filters_tools_gui import Ui_FiltersTool
from uidesigns.main_window_gui import Ui_ImageLab
from uidesigns.object_detection_tools_gui import Ui_ObjectDetectionTool
from uidesigns.resize_tools_gui import Ui_ResizeTool

class ImageLabMainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        
        # Initialize image states BEFORE calling UI setup
        self.original_pixmap = None
        self.processed_pixmap = None
        self.seams_pixmap = None

        self.ui = Ui_ImageLab()
        self.ui.setupUi(self)

        self.initialize_ui()

    def initialize_ui(self):
        """Initialize UI settings for QGraphicsView and zoom controls"""
        self.ui.progressBar.setVisible(False)
        self.ui.progressBar.setValue(0)
        
        # Initialize timing labels
        self.ui.timingLabel.setText("")
        self.ui.seamsTimingLabel.setText("")
        
        # Define aspect ratio presets
        self.aspect_ratios: Dict[str, Union[float, None]] = {
            "Original": None,
            "1:1": 1,
            "4:3": 4/3,
            "3:4": 3/4,
            "16:9": 16/9,
            "9:16": 9/16,
            "3:2": 3/2,
            "2:3": 2/3,
            "Custom": None
        }

        # Set up the QGraphicsView and QGraphicsScene for original image
        self.original_scene = QtWidgets.QGraphicsScene()
        self.ui.originalImagePreview.setScene(self.original_scene)
        
        # Set up the QGraphicsView and QGraphicsScene for processed image without seams
        self.processed_scene = QtWidgets.QGraphicsScene()
        self.ui.processedImageView.setScene(self.processed_scene)
        
        # Set up the QGraphicsView and QGraphicsScene for processed image with seams
        self.processed_with_seams_scene = QtWidgets.QGraphicsScene()
        self.ui.processedImageWithSeamsView.setScene(self.processed_with_seams_scene)

        self.all_graphics_views = [
            self.ui.originalImagePreview,
            self.ui.processedImageView,
            self.ui.processedImageWithSeamsView
        ]
        
        # Set view properties for all views
        for view in self.all_graphics_views:
            view.setRenderHint(QtGui.QPainter.Antialiasing)
            view.setRenderHint(QtGui.QPainter.SmoothPixmapTransform)
            view.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
            view.setAlignment(QtCore.Qt.AlignCenter)
            view.setBackgroundBrush(QtGui.QBrush(QtGui.QColor(248, 250, 252)))
        
        # Initialize zoom combo box
        self.initialize_zoom_combo_box()
        
        # Initialize seams mode combo box
        self.initialize_seams_mode_combo_box()
        
        # Connect the toggle scene button
        self.ui.toggleSceneBtn.clicked.connect(self.toggle_scene)
        
        # Connect the seams view button
        self.ui.seamsViewBtn.clicked.connect(self.toggle_seams_view)
        
        # Connect seams mode combo box
        self.ui.seamsModeComboBox.currentTextChanged.connect(self.on_seams_mode_changed)
        
        # Add placeholder text
        self.show_placeholder_text()
        
        # Start with original image view (Page 0)
        self.current_page_index = 0  # 0=original, 1=processedWithoutSeams, 2=processedWithSeams
        self.ui.stackedWidget.setCurrentIndex(self.current_page_index)
        
        # Initialize seam viewing state
        self.seams_view_active = False
        self.current_seams_mode = "All Seams"  # Default to all seams
        self.seam_visualizations = None
        
        # Initialize timing info
        self.timing_info = None
        
        # Initialize button states - all disabled initially
        self.ui.toggleSceneBtn.setEnabled(False)
        self.ui.seamsViewBtn.setEnabled(False)
        self.ui.seamsModeComboBox.setVisible(False)
        
        # Update UI state
        self.update_toggle_button_text()

    @property
    def current_scene(self) -> QtWidgets.QGraphicsScene:
        """Get the current active scene based on current_page_index"""
        if self.current_page_index == 0:  # Original image
            return self.original_scene
        elif self.current_page_index == 1:  # Processed image without seams
            return self.processed_scene
        else:  # Processed image with seams (page index 2)
            return self.processed_with_seams_scene

    @property
    def current_graphics_view(self) -> QtWidgets.QGraphicsView:
        """Get the current active graphics view based on current_page_index"""
        if self.current_page_index == 0:  # Original image
            return self.ui.originalImagePreview
        elif self.current_page_index == 1:  # Processed image without seams
            return self.ui.processedImageView
        else:  # Processed image with seams (page index 2)
            return self.ui.processedImageWithSeamsView

    def initialize_zoom_combo_box(self):
        """Initialize the zoom combo box with standard options"""
        zoom_options = [
            "Fit to View",
            "Actual Size", 
            "25%",
            "50%", 
            "75%",
            "100%",
            "125%",
            "150%",
            "200%",
            "300%",
            "400%"
        ]
        
        self.ui.selectStandardZoomComboBox.clear()
        self.ui.selectStandardZoomComboBox.addItems(zoom_options)
        self.ui.selectStandardZoomComboBox.setCurrentText("Fit to View")

    def initialize_seams_mode_combo_box(self):
        """Initialize the seams mode combo box"""
        self.ui.seamsModeComboBox.clear()
        self.ui.seamsModeComboBox.addItems(["All Seams", "Added Seams", "Removed Seams"])

    def show_placeholder_text(self):
        """Show placeholder text in all graphics views"""
        font = QtGui.QFont()
        font.setPointSize(12)
        
        # Original image view
        self.original_scene.clear()
        original_text_item = self.original_scene.addText("Upload or drag image here")
        original_text_item.setDefaultTextColor(QtGui.QColor(108, 117, 125))
        original_text_item.setFont(font)
        
        # Processed image view without seams
        self.processed_scene.clear()
        processed_text_item = self.processed_scene.addText("Processed image will appear here")
        processed_text_item.setDefaultTextColor(QtGui.QColor(108, 117, 125))
        processed_text_item.setFont(font)
        
        # Processed image view with seams
        self.processed_with_seams_scene.clear()
        seams_text_item = self.processed_with_seams_scene.addText("Seams visualization will appear here")
        seams_text_item.setDefaultTextColor(QtGui.QColor(108, 117, 125))
        seams_text_item.setFont(font)
        
        # Center the content
        self.center_content()

    def center_content(self):
        """Center the content in all graphics views"""
        for view, scene in [(self.ui.originalImagePreview, self.original_scene),
                           (self.ui.processedImageView, self.processed_scene),
                           (self.ui.processedImageWithSeamsView, self.processed_with_seams_scene)]:
            if scene.items():
                view.fitInView(scene.itemsBoundingRect(), QtCore.Qt.KeepAspectRatio)

    def toggle_scene(self):
        """Toggle between original and processed image views"""
        if not self.has_processed_image():
            return
            
        # If currently showing processed image with seams, switch to processed without seams first
        if self.current_page_index == 2:  # processed with seams
            self.ui.stackedWidget.setCurrentIndex(1)  # processed without seams (Page 1)
            self.current_page_index = 1
            self.seams_view_active = False
            self.ui.seamsViewBtn.setText("View Seams")
            self.ui.seamsModeComboBox.setVisible(False)
            
        # Toggle between original (0) and processed without seams (1)
        elif self.current_page_index == 0:  # Currently showing original
            self.ui.stackedWidget.setCurrentIndex(1)  # Switch to processed without seams
            self.current_page_index = 1
            # Show seam controls if available
            has_seams = self.seam_visualizations is not None
            self.ui.seamsViewBtn.setVisible(has_seams)
            self.ui.seamsModeComboBox.setVisible(False)  # Hide in processed without seams view
            
        else:  # Currently showing processed without seams (page index 1)
            self.ui.stackedWidget.setCurrentIndex(0)  # Switch to original
            self.current_page_index = 0
            # Hide seam controls when viewing original
            self.ui.seamsViewBtn.setVisible(False)
            self.ui.seamsModeComboBox.setVisible(False)
        
        # Update timing labels based on current page
        self.update_timing_display()
        self.update_toggle_button_text()

    def toggle_seams_view(self):
        """Toggle seam visualization on/off for processed image"""
        if not self.has_processed_image() or self.seam_visualizations is None:
            return
            
        self.seams_view_active = not self.seams_view_active
        
        if self.seams_view_active:
            # Turn ON seam view - switch to processed with seams page
            self.ui.stackedWidget.setCurrentIndex(2)  # processedImageWithSeamsPage (Page 2)
            self.current_page_index = 2
            self.ui.seamsViewBtn.setText("Hide Seams")
            self.ui.seamsModeComboBox.setVisible(True)
            self.show_processed_with_seams()
        else:
            # Turn OFF seam view - switch back to processed without seams page
            self.ui.stackedWidget.setCurrentIndex(1)  # processedImageWithoutSeamsPage (Page 1)
            self.current_page_index = 1
            self.ui.seamsViewBtn.setText("View Seams")
            self.ui.seamsModeComboBox.setVisible(False)
            self.show_processed_normal()
        
        # Update timing labels based on current page
        self.update_timing_display()
        self.update_toggle_button_text()

    def on_seams_mode_changed(self, mode_text):
        """Handle seam view mode change"""
        if not self.has_processed_image() or not self.seams_view_active or self.seam_visualizations is None:
            return
        
        self.current_seams_mode = mode_text
        self.show_processed_with_seams()

    def show_processed_normal(self):
        """Show processed image without seams (blended naturally)"""
        if self.processed_pixmap is not None:
            self.display_processed_image(self.processed_pixmap)

    def show_processed_with_seams(self):
        """Show processed image with seams based on current mode"""
        if self.seam_visualizations is None or not self.has_processed_image():
            return
        
        if self.current_seams_mode == "All Seams":
            self.show_all_seams()
        elif self.current_seams_mode == "Added Seams":
            self.show_added_seams()
        elif self.current_seams_mode == "Removed Seams":
            self.show_removed_seams()

    def show_all_seams(self):
        """Show processed image with ALL seams highlighted"""
        if self.seam_visualizations is not None and 'all' in self.seam_visualizations:
            seams_img = self.seam_visualizations['all']
            print("all seams_img", seams_img)
            if seams_img is not None:
                q_image = self.convert_cv_to_qimage(seams_img)
                if q_image:
                    pixmap = QtGui.QPixmap.fromImage(q_image)
                    self.display_processed_with_seams_image(pixmap)

    def show_removed_seams(self):
        """Show processed image with removed seams highlighted"""
        if self.seam_visualizations is not None and 'removed' in self.seam_visualizations:
            seams_img = self.seam_visualizations['removed']
            print("removed seams_img", seams_img)
            if seams_img is not None:
                q_image = self.convert_cv_to_qimage(seams_img)
                if q_image:
                    pixmap = QtGui.QPixmap.fromImage(q_image)
                    self.display_processed_with_seams_image(pixmap)

    def show_added_seams(self):
        """Show processed image with added seams highlighted"""
        if self.seam_visualizations is not None and 'added' in self.seam_visualizations:
            seams_img = self.seam_visualizations['added']
            print("added seams_img", seams_img)
            if seams_img is not None:
                q_image = self.convert_cv_to_qimage(seams_img)
                if q_image:
                    pixmap = QtGui.QPixmap.fromImage(q_image)
                    self.display_processed_with_seams_image(pixmap)

    def show_original_normal(self):
        """Show original image without seams"""
        if self.original_pixmap is not None:
            self.display_original_image(self.original_pixmap)

    def update_toggle_button_text(self):
        """Update the toggle button text based on current page"""
        if self.current_page_index == 0:  # Currently showing original
            self.ui.toggleSceneBtn.setText("View Processed")
        elif self.current_page_index == 1:  # Currently showing processed without seams
            self.ui.toggleSceneBtn.setText("View Original")
        else:  # Currently showing processed with seams (page 2)
            self.ui.toggleSceneBtn.setText("View Original")

    def update_button_states(self):
        """Update button states based on current state"""
        has_processed = self.has_processed_image()
        
        # Toggle button enabled only if we have processed image
        self.ui.toggleSceneBtn.setEnabled(has_processed)
        
        # Seams view button enabled only if we have processed image AND seam visualizations
        has_seams = self.seam_visualizations is not None
        self.ui.seamsViewBtn.setEnabled(has_processed and has_seams)
        
        # Show seams button only when in processed pages (1 or 2)
        in_processed_page = self.current_page_index in [1, 2]
        self.ui.seamsViewBtn.setVisible(in_processed_page and has_seams)
        
        # Show seams mode combo box only when viewing seams (page 2)
        self.ui.seamsModeComboBox.setVisible(self.current_page_index == 2)

    def show_original_image_page(self):
        """Switch to original image view"""
        self.ui.stackedWidget.setCurrentIndex(0)  # originalImagePage (Page 0)
        self.current_page_index = 0
        
        # Hide seam controls when viewing original
        self.ui.seamsViewBtn.setVisible(False)
        self.ui.seamsModeComboBox.setVisible(False)
        self.seams_view_active = False
        self.ui.seamsViewBtn.setText("View Seams")
        
        # Show original image normally
        self.show_original_normal()
        
        # Update button states
        self.update_toggle_button_text()
        self.update_button_states()
        
        # Clear timing display for original page
        self.ui.timingLabel.setText("")

    def show_processed_image_page(self):
        """Switch to processed image view without seams"""
        self.ui.stackedWidget.setCurrentIndex(1)  # processedImageWithoutSeamsPage (Page 1)
        self.current_page_index = 1
        
        # Show seam controls if available
        has_seams = self.seam_visualizations is not None
        self.ui.seamsViewBtn.setVisible(has_seams)
        self.ui.seamsModeComboBox.setVisible(False)  # Hidden in processed without seams view
        self.seams_view_active = False
        self.ui.seamsViewBtn.setText("View Seams")
        
        # Show processed image without seams
        self.show_processed_normal()
        
        # Update button states
        self.update_toggle_button_text()
        self.update_button_states()
        
        # Update timing display for processed page
        self.update_timing_display()

    def show_processed_with_seams_page(self):
        """Switch to processed image view with seams"""
        self.ui.stackedWidget.setCurrentIndex(2)  # processedImageWithSeamsPage (Page 2)
        self.current_page_index = 2
        
        # Show seam controls
        self.ui.seamsViewBtn.setVisible(True)
        self.ui.seamsModeComboBox.setVisible(True)
        self.seams_view_active = True
        self.ui.seamsViewBtn.setText("Hide Seams")
        
        # Show appropriate seam visualization
        self.show_processed_with_seams()
        
        # Update button states
        self.update_toggle_button_text()
        self.update_button_states()
        
        # Update timing display for seams page
        self.update_timing_display()

    def display_original_image(self, pixmap: Union[QtGui.QPixmap, None]):
        """Load and display original image"""
        if pixmap and not pixmap.isNull():
            self.original_scene.clear()
            original_pixmap_item = self.original_scene.addPixmap(pixmap)

            if original_pixmap_item:
                self.original_scene.setSceneRect(original_pixmap_item.boundingRect())
            self.ui.originalImagePreview.fitInView(self.original_scene.itemsBoundingRect(), QtCore.Qt.KeepAspectRatio)
            
            # Store the pixmap
            self.original_pixmap = pixmap
            
            # Switch to original image page (Page 0)
            self.current_page_index = 0
            self.ui.stackedWidget.setCurrentIndex(self.current_page_index)
            
            # Update button states
            self.update_toggle_button_text()
            self.update_button_states()
            
            # Clear timing for original image
            self.ui.timingLabel.setText("")
            self.ui.seamsTimingLabel.setText("")

    def display_processed_image(self, pixmap: Union[QtGui.QPixmap, None]):
        """Load and display processed image without seams"""
        if pixmap and not pixmap.isNull():
            self.processed_scene.clear()
            processed_pixmap_item = self.processed_scene.addPixmap(pixmap)

            if processed_pixmap_item:
                self.processed_scene.setSceneRect(processed_pixmap_item.boundingRect())
            self.ui.processedImageView.fitInView(self.processed_scene.sceneRect(), QtCore.Qt.KeepAspectRatio)
            
            # Store the pixmap
            self.processed_pixmap = pixmap
            
            # Switch to processed image page (Page 1)
            self.current_page_index = 1
            self.ui.stackedWidget.setCurrentIndex(self.current_page_index)
            
            # Update button states
            self.update_toggle_button_text()
            self.update_button_states()
            
            # Update timing display
            self.update_timing_display()

    def display_processed_with_seams_image(self, pixmap: Union[QtGui.QPixmap, None]):
        """Load and display processed image with seams visualization"""
        if pixmap and not pixmap.isNull():
            self.processed_with_seams_scene.clear()
            seams_pixmap_item = self.processed_with_seams_scene.addPixmap(pixmap)

            if seams_pixmap_item:
                self.processed_with_seams_scene.setSceneRect(seams_pixmap_item.boundingRect())
            self.ui.processedImageWithSeamsView.fitInView(self.processed_with_seams_scene.sceneRect(), QtCore.Qt.KeepAspectRatio)
            
            # Store the seams pixmap
            self.seams_pixmap = pixmap

    def convert_cv_to_qimage(self, cv_image):
        """Convert OpenCV image to QImage"""
        if cv_image is None:
            return None
            
        try:
            # Convert BGR to RGB for color images
            if len(cv_image.shape) == 3 and cv_image.shape[2] == 3:
                rgb_image = cv2.cvtColor(cv_image, cv2.COLOR_BGR2RGB)
            else:
                rgb_image = cv_image
            
            h, w = rgb_image.shape[:2]
            bytes_per_line = 3 * w if len(rgb_image.shape) == 3 else w
            
            # Create QImage
            if len(rgb_image.shape) == 3:
                q_img = QtGui.QImage(rgb_image.data, w, h, bytes_per_line, QtGui.QImage.Format_RGB888)
            else:
                q_img = QtGui.QImage(rgb_image.data, w, h, bytes_per_line, QtGui.QImage.Format_Grayscale8)
            
            return q_img.copy()  # Make a copy to avoid memory issues
        except Exception as e:
            print(f"Error converting CV image: {e}")
            return None

    def has_processed_image(self):
        """Check if a processed image exists"""
        return hasattr(self, 'processed_pixmap') and self.processed_pixmap is not None

    def set_seam_visualizations(self, visualizations: Dict):
        """Set seam visualizations for viewing"""
        if visualizations and isinstance(visualizations, dict):
            # Store all three visualization types
            self.seam_visualizations = {
                'all': visualizations.get('all'),  # Combined view
                'added': visualizations.get('added'),  # Added only
                'removed': visualizations.get('removed') # Removed only
            }
            
            # Update combo box options
            self.ui.seamsModeComboBox.clear()
            self.ui.seamsModeComboBox.addItems(["All Seams", "Added Seams", "Removed Seams"])
            self.ui.seamsModeComboBox.setCurrentText("All Seams")
            self.current_seams_mode = "All Seams"
            
            # Update button states
            self.update_button_states()
        else:
            self.seam_visualizations = None
            self.update_button_states()

    def enable_tool_buttons(self, enabled):
        """Enable or disable tool buttons based on image availability"""
        self.ui.resizeBtn.setEnabled(enabled)
        self.ui.filtersBtn.setEnabled(enabled)
        self.ui.obj_detectionBtn.setEnabled(enabled)
        
        # Update button states
        self.update_button_states()

    def update_timing_label(self, timing_info: Dict):
        """Update timing display label"""
        if timing_info:
            self.timing_info = timing_info
            self.update_timing_display()
        else:
            self.timing_info = None
            self.ui.timingLabel.setText("")
            self.ui.seamsTimingLabel.setText("")

    def update_timing_display(self):
        """Update timing display based on current page"""
        if not self.timing_info:
            self.ui.timingLabel.setText("")
            self.ui.seamsTimingLabel.setText("")
            return
        
        # Format timing information
        algorithm_time = self.timing_info.get('algorithm', 0.0)
        algorithm_name = self.timing_info.get('algorithm_name', 'Algorithm')
        
        timing_text = f"{algorithm_name}: {algorithm_time:.3f}s"
        
        # Update appropriate timing label based on current page
        if self.current_page_index == 1:  # Processed without seams page
            self.ui.timingLabel.setText(timing_text)
            self.ui.seamsTimingLabel.setText("")
        elif self.current_page_index == 2:  # Processed with seams page
            self.ui.seamsTimingLabel.setText(timing_text)
            self.ui.timingLabel.setText("")
        else:  # Original page (0) or other
            self.ui.timingLabel.setText("")
            self.ui.seamsTimingLabel.setText("")

    def update_dimension_labels(self):
        """Update dimension labels for all views"""
        if hasattr(self, 'original_pixmap') and self.original_pixmap is not None:
            w = self.original_pixmap.width()
            h = self.original_pixmap.height()
            self.ui.imageDimensionsLabel.setText(f"Width: {w} × Height: {h}")
        
        if hasattr(self, 'processed_pixmap') and self.processed_pixmap is not None:
            w = self.processed_pixmap.width()
            h = self.processed_pixmap.height()
            self.ui.processedDimensionsLabel.setText(f"Width: {w} × Height: {h}")
        
        if hasattr(self, 'seams_pixmap') and self.seams_pixmap is not None:
            w = self.seams_pixmap.width()
            h = self.seams_pixmap.height()
            self.ui.processedWithSeamsDimensionsLabel.setText(f"Width: {w} × Height: {h}")

    def reset_processed_state(self):
        """Reset processed image state"""
        self.processed_pixmap = None
        self.seams_pixmap = None
        self.seam_visualizations = None
        self.timing_info = None
        
        # Clear processed scenes
        self.processed_scene.clear()
        self.processed_with_seams_scene.clear()
        
        # Reset seam view state
        self.seams_view_active = False
        self.current_seams_mode = "All Seams"
        
        # Update UI
        self.ui.seamsViewBtn.setEnabled(False)
        self.ui.seamsViewBtn.setVisible(False)
        self.ui.seamsModeComboBox.setVisible(False)
        self.ui.seamsViewBtn.setText("View Seams")
        
        # Show placeholder for processed views
        font = QtGui.QFont()
        font.setPointSize(12)
        
        processed_text_item = self.processed_scene.addText("Processed image will appear here")
        processed_text_item.setDefaultTextColor(QtGui.QColor(108, 117, 125))
        processed_text_item.setFont(font)
        
        seams_text_item = self.processed_with_seams_scene.addText("Seams visualization will appear here")
        seams_text_item.setDefaultTextColor(QtGui.QColor(108, 117, 125))
        seams_text_item.setFont(font)
        
        # Clear labels
        self.ui.processedDimensionsLabel.setText("")
        self.ui.processedWithSeamsDimensionsLabel.setText("")
        self.ui.timingLabel.setText("")
        self.ui.seamsTimingLabel.setText("")
        
        # Update button states
        self.update_button_states()
        self.update_toggle_button_text()


class ResizeWidget(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        
        self.ui = Ui_ResizeTool()
        self.ui.setupUi(self)

        # Input validation
        int_validator = QtGui.QIntValidator(1, 100000)  # Add reasonable bounds
        self.ui.width_resize_lineEdit.setValidator(int_validator)
        self.ui.height_resize_lineEdit.setValidator(int_validator)

        # Connect signals
        self.ui.content_aware_checkBox.stateChanged.connect(self.content_aware_check_state)
        self.ui.content_aware_checkBox.toggled.connect(self.toggle_algorithm_visibility)
        
        # Initialize UI state
        self.content_aware_check_state()
        self.toggle_algorithm_visibility(self.ui.content_aware_checkBox.isChecked())

        # Aspect ratio options
        self.ui.resize_image_comboBox.clear()
        self.ui.resize_image_comboBox.addItems([
            "Custom",
            "Original", 
            "1:1", 
            "4:3", 
            "3:4", 
            "16:9", 
            "9:16", 
            "3:2", 
            "2:3",
        ])

        # Aspect ratio options
        self.ui.resize_algorithm_comboBox.clear()
        self.ui.resize_algorithm_comboBox.addItems([
            "Hubble 001",
            "Hubble 002",
            "Hubble 003",
        ])

        # Window configuration
        self.setWindowFlags(
            QtCore.Qt.Tool | 
            QtCore.Qt.Dialog | 
            QtCore.Qt.WindowCloseButtonHint |
            QtCore.Qt.WindowTitleHint
        )
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose, False)
        self.setWindowModality(QtCore.Qt.NonModal)

    def get_resize_parameters(self):
        """Get all resize parameters from the UI"""
        return {
            'width': int(self.ui.width_resize_lineEdit.text()) if self.ui.width_resize_lineEdit.text() else None,
            'height': int(self.ui.height_resize_lineEdit.text()) if self.ui.height_resize_lineEdit.text() else None,
            'content_aware': self.ui.content_aware_checkBox.isChecked(),
            'algorithm': self.ui.resize_algorithm_comboBox.currentText() if self.ui.content_aware_checkBox.isChecked() else None,
            'aspect_ratio': self.ui.resize_image_comboBox.currentText()
        }

    def reset_form(self):
        """Reset all form fields to default values"""
        self.ui.width_resize_lineEdit.clear()
        self.ui.height_resize_lineEdit.clear()
        self.ui.content_aware_checkBox.setChecked(True)
        self.ui.resize_algorithm_comboBox.setCurrentIndex(0)
        self.ui.resize_image_comboBox.setCurrentIndex(0)    

    def content_aware_check_state(self):
        """
        Toggle text bold based on checkbox state using QFont
        """
        font = self.ui.content_aware_checkBox.font()
        font.setBold(self.ui.content_aware_checkBox.isChecked())
        self.ui.content_aware_checkBox.setFont(font)

    # Add this method to your class:
    def toggle_algorithm_visibility(self, checked):
        """Show/hide algorithm selection based on content-aware checkbox state"""
        self.ui.algorithmWidget.setVisible(checked)

class FilterWidget(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        
        self.ui = Ui_FiltersTool()
        self.ui.setupUi(self)

        # Dialog-like appearance and behavior
        self.setWindowFlags(
            QtCore.Qt.Tool | 
            QtCore.Qt.Dialog | 
            QtCore.Qt.WindowCloseButtonHint |
            QtCore.Qt.WindowTitleHint
        )
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose, False)
        self.setWindowModality(QtCore.Qt.NonModal)


class ObjectDetectionWidget(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        
        self.ui = Ui_ObjectDetectionTool()
        self.ui.setupUi(self)

        self.ui.boundinBoxPreviewCheckbox.stateChanged.connect(self.bound_box_preview_state)
        self.bound_box_preview_state()

        # Dialog-like appearance and behavior
        self.setWindowFlags(
            QtCore.Qt.Tool | 
            QtCore.Qt.Dialog | 
            QtCore.Qt.WindowCloseButtonHint |
            QtCore.Qt.WindowTitleHint
        )
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose, False)
        self.setWindowModality(QtCore.Qt.NonModal)

    def bound_box_preview_state(self):
        """
        Toggle text bold based on checkbox state using QFont
        """
        font = self.ui.boundinBoxPreviewCheckbox.font()
        font.setBold(self.ui.boundinBoxPreviewCheckbox.isChecked())
        self.ui.boundinBoxPreviewCheckbox.setFont(font)












"""
image_lab.py
Main application window for ImageLab with seam viewing
"""

from pathlib import Path
from typing import Union
from utilities.processing import ImageProcessor
from views.widgets import FilterWidget, ImageLabMainWindow, ObjectDetectionWidget, ResizeWidget
from PyQt5 import QtCore, QtGui, QtWidgets
import cv2

class ImageLab(ImageLabMainWindow):
    def __init__(self):
        super().__init__()

        # Enable mouse wheel zoom
        self.ui.originalImagePreview.wheelEvent = self.graphics_view_wheel_event
        self.ui.processedImageView.wheelEvent = self.graphics_view_wheel_event

        self.resize_widget = ResizeWidget(self)
        self.filter_widget = FilterWidget(self)
        self.object_detection_widget = ObjectDetectionWidget(self)

        self.image_processor = None

        # Track the currently active tool
        self.current_tool = None
        
        # Track current image
        self.original_image = None
        self.original_image_path = None

        # Track processed image
        self.processed_image = None
        self.processed_image_path = None
        
        # Seam images
        self.removed_seams_image = None
        self.inserted_seams_image = None
        
        # Zoom tracking
        self.current_zoom_level = 1.0
        self.min_zoom = 0.1
        self.max_zoom = 10.0

        self.ui.resizeBtn.clicked.connect(self.processing_tool_selection)
        self.ui.obj_detectionBtn.clicked.connect(self.processing_tool_selection)
        self.ui.filtersBtn.clicked.connect(self.processing_tool_selection)

        # Connect UploadButton
        self.ui.UploadButton.clicked.connect(self.select_and_display_image)

        # Connect Save button
        self.ui.save_as_pushButton.clicked.connect(self.save_resized_image)
        
        # Connect Zoom ComboBox
        self.ui.selectStandardZoomComboBox.currentTextChanged.connect(self.apply_standard_zoom)

        self.ui.zoomInButton.clicked.connect(lambda: self.apply_zoom_in(5))
        self.ui.zoomOutButton.clicked.connect(lambda: self.apply_zoom_out(5))

        # Connect signals
        self.resize_widget.ui.width_resize_lineEdit.textChanged.connect(self.on_width_changed)
        self.resize_widget.ui.height_resize_lineEdit.textChanged.connect(self.on_height_changed)
        self.resize_widget.ui.resize_image_comboBox.currentTextChanged.connect(self.on_aspect_ratio_changed)

        self.resize_widget.ui.cancel_resize_btn.clicked.connect(self.close_resize_widget)
        self.resize_widget.ui.apply_resize_btn.clicked.connect(self.resize_image)

        self.close_shortcut = QtWidgets.QShortcut(QtGui.QKeySequence("Esc"), self)
        self.close_shortcut.activated.connect(self.close_active_tool)
 

    def apply_standard_zoom(self, zoom_option: str):
        """Apply standard zoom level based on combo box selection"""
        if not self.has_current_scene_content():
            return
            
        if zoom_option == "Fit to View":
            self.zoom_fit_to_view()
        elif zoom_option == "Actual Size":
            self.zoom_actual_size()
        elif zoom_option.endswith('%'):
            self.zoom_by_percentage(zoom_option)
        elif "custom" in zoom_option.lower():
            self.show_custom_zoom_dialog()

    def zoom_fit_to_view(self):
        """Zoom to fit the entire image in all views"""
        if self.has_current_scene_content():
            # Apply fit to view for all graphics views
            for graphics_view in self.all_graphics_views:
                if graphics_view.scene() and not graphics_view.scene().sceneRect().isEmpty():
                    graphics_view.fitInView(graphics_view.scene().sceneRect(), QtCore.Qt.KeepAspectRatio)
            
            self.current_zoom_level = self.calculate_current_zoom_level()
            self.update_zoom_combo_box_display()

    def zoom_actual_size(self):
        """Zoom to 100% (actual pixel size) for all views"""
        if self.has_current_scene_content():
            self.apply_zoom_level(1.0)

    def zoom_by_percentage(self, percentage_text):
        """Zoom by percentage value for all views"""
        if not self.has_current_scene_content():
            return
            
        try:
            # Extract percentage number from text (remove % sign)
            percentage = float(percentage_text.rstrip('%'))
            zoom_level = percentage / 100.0
            
            if self.min_zoom <= zoom_level <= self.max_zoom:
                self.apply_zoom_level(zoom_level)
                
        except ValueError:
            print(f"Invalid percentage format: {percentage_text}")

    def apply_zoom_in(self, zoom_factor=5):
        if self.has_current_scene_content():
            current_zoom = self.calculate_current_zoom_level()
            
            # Convert to percentage for easier calculation
            current_percent = current_zoom * 100
            
            # Find the next multiple of zoom_factor
            next_multiple = ((current_percent + zoom_factor - 1) // zoom_factor) * zoom_factor
            
            # Ensure we're moving forward by at least one step
            if next_multiple <= current_percent:
                next_multiple += zoom_factor
                
            zoom_level = next_multiple / 100.0
            
            zoom_level = max(self.min_zoom, min(self.max_zoom, zoom_level))
            self.apply_zoom_level(zoom_level)

    def apply_zoom_out(self, zoom_factor=5):
        if self.has_current_scene_content():
            current_zoom = self.calculate_current_zoom_level()
            
            # Convert to percentage for easier calculation
            current_percent = current_zoom * 100
            
            # Find the previous multiple of zoom_factor
            prev_multiple = ((current_percent - 1) // zoom_factor) * zoom_factor
            
            # Ensure we're moving backward by at least one step
            if prev_multiple >= current_percent:
                prev_multiple -= zoom_factor
                
            zoom_level = prev_multiple / 100.0
            
            zoom_level = max(self.min_zoom, min(self.max_zoom, zoom_level))
            self.apply_zoom_level(zoom_level)

    def apply_zoom_level(self, zoom_level):
        """Apply specific zoom level to all views"""
        if not self.has_current_scene_content():
            return
            
        # Clamp zoom level to min/max values
        zoom_level = max(self.min_zoom, min(self.max_zoom, zoom_level))
        
        # Apply zoom to all graphics views
        for graphics_view in self.all_graphics_views:
            # Reset transformation
            transform = QtGui.QTransform()
            # Apply zoom
            transform.scale(zoom_level, zoom_level)
            graphics_view.setTransform(transform)
        
        self.current_zoom_level = zoom_level
        self.update_zoom_combo_box_display()

    def calculate_current_zoom_level(self):
        """Calculate current zoom level based on current view transformation"""
        if not self.has_current_scene_content():
            return 1.0
            
        # Get the transform and extract scale from current view
        transform = self.current_graphics_view.transform()
        return transform.m11()  # Horizontal scale component

    def has_current_scene_content(self) -> bool:
        """Check if the current scene has any content to display"""
        if not self.current_scene:
            return False
            
        # Check if scene has any items
        if not self.current_scene.items():
            return False
            
        # Check if scene has a valid rect (not empty)
        scene_rect = self.current_scene.sceneRect()
        if scene_rect.isNull() or scene_rect.isEmpty():
            return False
            
        # Additional check based on current scene type
        if self.current_page_index == 0:  # Processed image view
            # Check if processed scene has content
            return hasattr(self, 'processed_scene') and self.processed_scene.items()
        else:  # Original image view
            # Check if original image exists
            return hasattr(self, 'original_image') and self.original_image is not None
        

    def get_zoom_combo_box_items(self):
        combo = self.ui.selectStandardZoomComboBox
        return [combo.itemText(i) for i in range(combo.count())]

    def update_zoom_combo_box_display(self):
        """Update combo box to reflect current zoom level, without triggering events"""
        # Block signals to prevent infinite loop
        self.ui.selectStandardZoomComboBox.blockSignals(True)
        
        # Calculate percentage
        percentage = int(self.current_zoom_level * 100)
        
        # Check if it matches any standard option
        standard_option = f"{percentage}%"
        index = self.ui.selectStandardZoomComboBox.findText(standard_option)
        
        if index >= 0:
            self.ui.selectStandardZoomComboBox.setCurrentText(standard_option)
        else:
            custom_index = self.ui.selectStandardZoomComboBox.findText(
                "^Custom", QtCore.Qt.MatchRegularExpression
            )
            if custom_index >= 0:
                # Use the existing custom item
                self.ui.selectStandardZoomComboBox.setCurrentIndex(custom_index)
                # Update it to show the current percentage
                self.ui.selectStandardZoomComboBox.setItemText(
                    custom_index, 
                    f"Custom ({percentage}%)"
                )
            else:
                # Fallback: just set text directly
                self.ui.selectStandardZoomComboBox.setCurrentText(f"Custom ({percentage}%)")
        
        # Restore signals
        self.ui.selectStandardZoomComboBox.blockSignals(False)

    def show_custom_zoom_dialog(self):
        """Show dialog for custom zoom input"""
        if not self.original_image:
            return
            
        current_percentage = int(self.current_zoom_level * 100)
        
        zoom_value, ok = QtWidgets.QInputDialog.getInt(
            self,
            "Custom Zoom",
            "Enter zoom percentage:",
            value=current_percentage,
            min=10,   # 10%
            max=1000, # 1000%
            step=10
        )
        
        if ok:
            zoom_level = zoom_value / 100.0
            self.apply_zoom_level(zoom_level)

    def graphics_view_wheel_event(self, event:QtGui.QWheelEvent):
        """Handle mouse wheel events for zooming"""
        if not self.has_image_loaded():
            return
        
        if event.modifiers() & QtCore.Qt.ControlModifier:
            # Zoom with Ctrl + Mouse Wheel
            zoom_factor = 1.0  # 10% zoom per step
            if event.angleDelta().y() > 0:
                # Zoom in
                new_zoom = self.current_zoom_level * zoom_factor
            else:
                # Zoom out
                new_zoom = self.current_zoom_level / zoom_factor
            
            # Clamp zoom level
            new_zoom = max(self.min_zoom, min(self.max_zoom, new_zoom))
            
            # Apply zoom
            self.apply_zoom_level(new_zoom)
            
            # Update combo box
            self.update_zoom_combo_box_display()
            
            event.accept()
        else:
            # Default wheel behavior (scroll)
            QtWidgets.QGraphicsView.wheelEvent(self.ui.originalImagePreview, event)
            QtWidgets.QGraphicsView.wheelEvent(self.ui.processedImageView, event)


    def select_and_display_image(self):
        """Select an image file and display it in the preview"""
        # Supported image formats
        file_filter = "Image Files (*.png *.jpg *.jpeg *.bmp *.gif *.tiff *.webp);;All Files (*)"
        
        # Open file dialog
        file_path, _ = QtWidgets.QFileDialog.getOpenFileName(
            self,
            "Choose an Image",
            str(Path.home()),  # Start from home directory
            file_filter
        )
        
        if file_path:
            self.load_and_display_image(file_path)

    def load_and_display_image(self, file_path):
        """Load image from file path and display in preview"""
        try:
            
            # Load image
            pixmap = QtGui.QPixmap(file_path)
            
            if pixmap.isNull():
                QtWidgets.QMessageBox.warning(self, "Error", "Unable to load image file.")
                return
            
            # Store image data
            self.original_image_path = file_path
            self.original_image = pixmap
            
            # Display image in QGraphicsView
            self.display_original_image(pixmap)
            
            # Reset to "Fit to View" when new image is loaded
            self.ui.selectStandardZoomComboBox.setCurrentText("Fit to View")
            self.zoom_fit_to_view()
            
            # Update window title with filename
            filename = Path(file_path).name
            self.setWindowTitle(f"ImageLab - {filename}")
            
            # Enable tool buttons if they were disabled
            self.enable_tool_buttons(True)

            self.image_processor = ImageProcessor(file_path)
            
            if self.image_processor.is_image_loaded():
                self.statusBar().showMessage(f"Successfully loaded image: {file_path}", 5000)

                self.show_original_image_page()
                w, h = self.image_processor.get_image_dimensions()

                # Store original dimensions and aspect ratio
                self.original_width = w
                self.original_height = h
                self.aspect_ratio = w / h if h != 0 else 1

                self.aspect_ratios.update({
                    "Original": self.aspect_ratio
                })

                # Set initial values
                self.ui.imageDimensionsLabel.setText(f"Width: {w} × Height: {h}")
                self.resize_widget.ui.width_resize_lineEdit.setText(str(w))
                self.resize_widget.ui.height_resize_lineEdit.setText(str(h))
            
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"Failed to load image: {str(e)}")

    def on_aspect_ratio_changed(self, ratio_name):
        """When aspect ratio selection changes"""
        if ratio_name == "Custom":
            return  # Don't auto-adjust in custom mode
        
        aspect_ratio = self.aspect_ratios[ratio_name]
        
        try:
            current_width = int(self.resize_widget.ui.width_resize_lineEdit.text())
            current_height = int(self.resize_widget.ui.height_resize_lineEdit.text())
            
            
            if all([current_width > 0, current_height > 0, aspect_ratio > 0]):
                if current_width / current_height > aspect_ratio:
                    new_height = int(current_width / aspect_ratio)
                    self.resize_widget.ui.height_resize_lineEdit.blockSignals(True)
                    self.resize_widget.ui.height_resize_lineEdit.setText(str(new_height))
                    self.resize_widget.ui.height_resize_lineEdit.blockSignals(False)
                else:
                    new_width = int(current_height * aspect_ratio)
                    self.resize_widget.ui.width_resize_lineEdit.blockSignals(True)
                    self.resize_widget.ui.width_resize_lineEdit.setText(str(new_width))
                    self.resize_widget.ui.width_resize_lineEdit.blockSignals(False)
            
        except ValueError:
            pass

    def on_width_changed(self, width_text):
        """When width line edit changes"""
        if self.resize_widget.ui.resize_image_comboBox.currentText() == "Custom":
            return  # Don't auto-adjust in custom mode
        
        try:
            width = int(width_text)
            ratio_name = self.resize_widget.ui.resize_image_comboBox.currentText()
            aspect_ratio = self.aspect_ratios[ratio_name]
            
            new_height = int(round(width / aspect_ratio))
            
            # Block signals to prevent recursive calls
            self.resize_widget.ui.height_resize_lineEdit.blockSignals(True)
            self.resize_widget.ui.height_resize_lineEdit.setText(str(new_height))
            self.resize_widget.ui.height_resize_lineEdit.blockSignals(False)
            
        except ValueError:
            pass  # Invalid input

    def on_height_changed(self, height_text):
        """When height line edit changes"""
        if self.resize_widget.ui.resize_image_comboBox.currentText() == "Custom":
            return  # Don't auto-adjust in custom mode
        
        try:
            height = int(height_text)
            ratio_name = self.resize_widget.ui.resize_image_comboBox.currentText()
            aspect_ratio = self.aspect_ratios[ratio_name]
            
            new_width = int(round(height * aspect_ratio))
            
            # Block signals to prevent recursive calls
            self.resize_widget.ui.width_resize_lineEdit.blockSignals(True)
            self.resize_widget.ui.width_resize_lineEdit.setText(str(new_width))
            self.resize_widget.ui.width_resize_lineEdit.blockSignals(False)
            
        except ValueError:
            pass

    def clear_image_preview(self, scene:QtWidgets.QGraphicsScene):
        """Clear the image preview and reset to placeholder state"""
        scene.clear()
        self.original_image = None
        self.original_image_path = None
        self.original_image = None
        self.current_zoom_level = 1.0
        
        # Reset to placeholder state
        self.show_placeholder_text()
        
        # Reset zoom combo box
        self.ui.selectStandardZoomComboBox.setCurrentText("Fit to View")
        
        # Reset window title
        self.setWindowTitle("ImageLab")
        
        # Disable tool buttons when no image is loaded
        self.enable_tool_buttons(False)

    def enable_tool_buttons(self, enabled):
        """Enable or disable tool buttons based on image availability"""
        self.ui.resizeBtn.setEnabled(enabled)
        self.ui.filtersBtn.setEnabled(enabled)
        self.ui.obj_detectionBtn.setEnabled(enabled)

    def resize_event(self, event):
        """Handle window resize to update image preview scaling"""
        super().resizeEvent(event)
        if self.original_image and self.ui.selectStandardZoomComboBox.currentText() == "Fit to View":
            self.zoom_fit_to_view()

    def get_original_image(self):
        """Get the current loaded image as QPixmap"""
        return self.original_image

    def get_original_image_path(self):
        """Get the path of the current loaded image"""
        return self.original_image_path

    def has_image_loaded(self):
        """Check if an image is currently loaded"""
        return self.original_image is not None

    # Add Drag and Drop Support
    def drag_enter_event(self, event):
        """Handle drag enter event for file drops"""
        if event.mimeData().hasUrls():
            # Check if any of the dragged files are images
            for url in event.mimeData().urls():
                file_path = url.toLocalFile()
                if self.is_image_file(file_path):
                    event.acceptProposedAction()
                    return
        event.ignore()

    def drag_move_event(self, event):
        """Handle drag move event"""
        if event.mimeData().hasUrls():
            for url in event.mimeData().urls():
                file_path = url.toLocalFile()
                if self.is_image_file(file_path):
                    event.acceptProposedAction()
                    return
        event.ignore()

    def drop_event(self, event):
        """Handle drop event for image files"""
        for url in event.mimeData().urls():
            file_path = url.toLocalFile()
            if self.is_image_file(file_path):
                self.load_and_display_image(file_path)
                event.acceptProposedAction()
                return
        event.ignore()

    def is_image_file(self, file_path:str):
        """Check if file is a supported image format"""
        image_extensions = {'.png', '.jpg', '.jpeg', '.bmp', '.gif', '.tiff', '.webp'}
        file_path = Path(file_path)
        return file_path.is_file() and file_path.suffix.lower() in image_extensions

    # Enable drag and drop for the main window
    def set_accept_drops(self, accept):
        """Override to enable drag and drop for the main window and graphics view"""
        super().setAcceptDrops(accept)
        self.ui.originalImagePreview.setAcceptDrops(accept)

    def position_tool_widget(self, widget: Union[FilterWidget, ObjectDetectionWidget, ResizeWidget], side="right", margin=10):
        """Position tool widget with screen boundary checking"""
        main_window_geometry = self.geometry()
        screen_geometry = QtWidgets.QApplication.primaryScreen().availableGeometry()
        
        if side == "right":
            x = main_window_geometry.right() + margin
            y = main_window_geometry.top()
            
            # Check if widget would go off-screen to the right
            if x + widget.width() > screen_geometry.right():
                # Position to the left instead
                x = main_window_geometry.left() - widget.width() - margin
                
        elif side == "left":
            x = main_window_geometry.left() - widget.width() - margin
            y = main_window_geometry.top()
            
            # Check if widget would go off-screen to the left
            if x < screen_geometry.left():
                # Position to the right instead
                x = main_window_geometry.right() + margin
        
        # Ensure widget stays within screen vertically
        if y + widget.height() > screen_geometry.bottom():
            y = screen_geometry.bottom() - widget.height()
        if y < screen_geometry.top():
            y = screen_geometry.top()
            
        widget.move(x, y)

    def processing_tool_selection(self):
        """Handle tool selection with image validation"""
        # Check if an image is loaded before showing tools
        if not self.has_image_loaded():
            QtWidgets.QMessageBox.information(
                self, 
                "No Image", 
                "Please select an image first before using tools."
            )
            return
        
        self.show_original_image_page()

        sender = self.sender()
        tool_to_show = None 

        if sender == self.ui.resizeBtn:
            tool_to_show = self.resize_widget
        elif sender == self.ui.filtersBtn:
            tool_to_show = self.filter_widget
        elif sender == self.ui.obj_detectionBtn:
            tool_to_show = self.object_detection_widget
        
        if tool_to_show:
            # Always hide the current tool first
            if self.current_tool:
                self.current_tool.hide()
            
            # If clicking the same tool button, toggle visibility
            if self.current_tool == tool_to_show:
                self.current_tool = None
            else:
                # Show the new tool and update current_tool
                self.position_tool_widget(tool_to_show, "right")
                tool_to_show.show()
                self.current_tool = tool_to_show

    def close_resize_widget(self):
        """Close the resize widget"""
        if self.current_tool == self.resize_widget:
            self.resize_widget.hide()
            self.current_tool = None

    def close_active_tool(self):
        """Close the currently active tool with Escape key"""
        if self.current_tool:
            self.current_tool.hide()
            self.current_tool = None

    def resize_image(self):
        """Resize the current image with the specified parameters"""
        if not self.has_image_loaded():
            QtWidgets.QMessageBox.warning(self, "No Image", "Please load an image first.")
            return
        
        if not self.image_processor:
            QtWidgets.QMessageBox.warning(self, "Could not resize", "Image processor not initialized")
            return
        
        try:
            # Get width and height from line edits
            new_width: int = int(self.resize_widget.ui.width_resize_lineEdit.text())
            new_height: int = int(self.resize_widget.ui.height_resize_lineEdit.text())
            
            # Validate dimensions
            if any([new_width <= 0, new_height <= 0]):
                QtWidgets.QMessageBox.warning(
                    self, 
                    "Invalid Dimensions", 
                    "Width and height must be positive numbers."
                )
                return
            
            if any([new_width > 10000, new_height > 10000]):
                QtWidgets.QMessageBox.warning(
                    self,
                    "Dimensions Too Large",
                    "Width and height cannot exceed 10000 pixels."
                )
                return
            
            # Get content-aware setting
            content_aware = self.resize_widget.ui.content_aware_checkBox.isChecked()
            
            # Determine algorithm
            content_aware_alg = self.resize_widget.ui.resize_algorithm_comboBox.currentText()

            # Setup progress bar for content-aware resizing
            if content_aware:
                self.ui.progressBar.setVisible(True)
                self.ui.progressBar.setValue(0)
                QtWidgets.QApplication.processEvents()  # Force UI update
            
                # Perform content-aware resize operation
                success = self.image_processor.resize_image(
                    new_width=new_width,
                    new_height=new_height,
                    content_aware=content_aware,
                    content_aware_alg=content_aware_alg,
                    progress_callback=self.update_progress
                )
            else:
                # Perform the traditional resize operation
                success = self.image_processor.resize_image(
                    new_width=new_width,
                    new_height=new_height,
                )

            # Hide progress bar when done
            if content_aware:
                self.ui.progressBar.setVisible(False)
            
            if success:
                # Get the processed image and timing info
                result = self.image_processor.get_processed_image()
                
                if result:
                    self.processed_image, timing_info, seam_info = result
                    
                    # Update timing display
                    if timing_info:
                        self.update_timing_label(timing_info)
                    
                    # Get seam visualizations
                    seam_visualizations = None
                    if self.image_processor is not None:
                        seam_visualizations = self.image_processor.get_seam_visualizations()
                    
                    if seam_visualizations:
                        self.set_seam_visualizations(seam_visualizations)
                    
                    # Convert and display the processed image
                    q_image = self.image_processor.convert_cv_image(self.processed_image, output_format="qimage")
                    if q_image:
                        height, width, _ = self.processed_image.shape
                        pixmap = QtGui.QPixmap.fromImage(q_image)
                        
                        # Update the display
                        self.show_processed_image_page()
                        self.display_processed_image(pixmap)
                        self.ui.selectStandardZoomComboBox.setCurrentText("Fit to View")
                        self.zoom_fit_to_view()
                        
                        # Update dimensions label
                        self.ui.processedDimensionsLabel.setText(f"Width: {width} × Height: {height}")
                        
                        # Enable toggle buttons
                        self.ui.toggleSceneBtn.setEnabled(True)
                        
                        # Show success message
                        self.statusBar().showMessage(
                            f"Image resized to {width}×{height} pixels", 
                            3000
                        )
                        
                        # Close the resize widget after successful operation
                        self.close_resize_widget()
                    else:
                        QtWidgets.QMessageBox.critical(
                            self,
                            "Resize Error",
                            "Failed to get resized image from processor."
                        )
                else:
                    QtWidgets.QMessageBox.critical(
                        self,
                        "Resize Failed",
                        "Image processor failed to resize the image."
                    )
                    
                # Reset to original for next operation
                self.image_processor.reset_to_original()
                
        except ValueError as e:
            print(e)
            QtWidgets.QMessageBox.warning(
                self,
                "Invalid Input",
                "Please enter valid numeric values for width and height."
            )
        except Exception as e:
            QtWidgets.QMessageBox.critical(
                self,
                "Resize Error",
                f"An unexpected error occurred: {str(e)}"
            )

    def update_progress(self, value, maximum=None):
        """Update progress bar with current value"""
        if maximum is not None:
            self.ui.progressBar.setMaximum(maximum)
        self.ui.progressBar.setValue(value)
        QtWidgets.QApplication.processEvents()  # Force UI update

    def save_resized_image(self):
        """Save the processed image to a file"""
        if self.processed_image is None:
            QtWidgets.QMessageBox.warning(self, "Warning", "No processed image to save!")
            return
        
        # Get image dimensions
        height, width, _ = self.processed_image.shape
        
        # Generate default filename
        default_filename = (
            f"{self.image_processor.get_image_filename()}"
            f"_resized_{width}_{height}"
            f"{self.image_processor.get_image_extension()}"
        )
        
        # Default directory
        default_directory = self.image_processor.get_image_directory()
        default_path = str(Path(default_directory) / default_filename)
        
        # Supported image formats for saving
        file_filter = "Image Files (*.png *.jpg *.jpeg *.bmp *.gif *.tiff *.webp);;All Files (*)"
        
        # Open save file dialog
        file_path, _ = QtWidgets.QFileDialog.getSaveFileName(
            self,
            "Save Resized Image",
            default_path,
            file_filter
        )
        
        if file_path:
            try:
                image_saved = self.image_processor.save_image(file_path, self.processed_image)
                if image_saved:
                    message = f'Image saved successfully!<br><br>Location: <a href="file:///{file_path}">{file_path}</a>'
                    QtWidgets.QMessageBox.information(self, "Success", message)
                else:
                    QtWidgets.QMessageBox.critical(self, "Error", "Failed to save processed image!")
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "Error", f"Error saving image: {str(e)}")


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    image_processor = ImageLab()
    
    # Enable drag and drop
    image_processor.setAcceptDrops(True)
    image_processor.ui.originalImagePreview.setAcceptDrops(True)
    
    image_processor.show()
    sys.exit(app.exec_())





"""
utilities/processing.py
Image processing utilities for loading, resizing, and saving images
"""

from pathlib import Path
import cv2 as cv
from PyQt5.QtGui import QImage, QPixmap
import numpy as np

from utilities.seam_carving_algorithms import SeamCarver, SeamCarverHubble001, SeamCarverHubble002

class ImageProcessor:
    def __init__(self, file_path):
        self.image_path = Path(file_path)
        self.current_image = None
        self.original_image = None
        self.last_timing_info = None
        self.last_seam_info = None
        self.last_algorithm_used = None
        
        self.load_image()
        
    def load_image(self):
        """Load an image from file path"""
        try:
            image_path = self.image_path
            if not self._is_valid_image_path(image_path):
                return False
            
            self.original_image = cv.imread(str(image_path))
            if self.original_image is None:
                raise ValueError(f"Could not load image from {image_path}")
            
            self.current_image = self.original_image.copy()
            return True
        except Exception as e:
            print(f"Error loading image: {e}")
            return False
    
    def _is_valid_image_path(self, image_path):
        """Validate if the file path exists and is a valid image file"""
        if not image_path or not isinstance(image_path, Path):
            print("Error: Invalid file path provided")
            return False
            
        if not image_path.exists():
            print(f"Error: File does not exist: {image_path}")
            return False
            
        if not image_path.is_file():
            print(f"Error: Path is not a file: {image_path}")
            return False
            
        return True
    
    def is_image_loaded(self):
        """Check if an image is currently loaded"""
        return self.current_image is not None and self.original_image is not None
    
    def get_image_info(self):
        """Get information about the currently loaded image"""
        if not self.is_image_loaded():
            return "No image loaded"
        
        height, width = self.current_image.shape[:2]
        channels = self.current_image.shape[2] if len(self.current_image.shape) > 2 else 1
        
        file_size = self.image_path.stat().st_size if self.image_path and self.image_path.exists() else 0
        
        return {
            'path': str(self.image_path),
            'dimensions': f"{width}x{height}",
            'channels': channels,
            'size': f"{file_size / 1024:.2f} KB"
        }

    def get_image_directory(self):
        """Get the directory containing the current image"""
        if self.image_path:
            return self.image_path.parent
        return None
    
    def get_image_filename(self):
        """Get the filename without extension"""
        if self.image_path:
            return self.image_path.stem
        return None
    
    def get_image_extension(self):
        """Get the file extension"""
        if self.image_path:
            return self.image_path.suffix
        return None
    
    def get_image_dimensions(self):
        """Get current image dimensions"""
        if self.current_image is not None:
            height, width = self.current_image.shape[:2]
            return width, height
        return 0, 0
    
    def resize_image(self, new_width=None, new_height=None, **kwargs):
        """Resize the current image
        
        Args:
            new_width: Target width (required)
            new_height: Target height (required)
            **kwargs: Additional options:
                - content_aware: Use content-aware resizing (default: False)
                - content_aware_alg: Algorithm for content-aware resizing
                - progress_callback: Callback for progress updates
        
        Returns:
            success: Boolean indicating if resize was successful
        """
        if self.current_image is None:
            return False
        
        # We need target dimensions
        if new_width is None or new_height is None:
            raise ValueError("Width and height are required for content-aware resize")
        
        # Convert to integers and validate
        try:
            new_width = int(new_width)
            new_height = int(new_height)
        except (ValueError, TypeError) as e:
            raise ValueError(f"Width and height must be numeric values: {e}")
        
        # We need target dimensions
        if new_width <= 0 or new_height <= 0:
            raise ValueError("Width and height values must be greater than 0")
        
        # Extract kwargs with default values
        content_aware = kwargs.get('content_aware', False)
        content_aware_alg = kwargs.get('content_aware_alg', None)
        progress_callback = kwargs.get('progress_callback', None)
        
        try:
            if content_aware:
                # Store the algorithm used
                self.last_algorithm_used = content_aware_alg
                
                # Use seam carving with seam information
                result = self._seam_carving_resize(
                    new_width, new_height, 
                    algorithm=content_aware_alg,
                    progress_callback=progress_callback,
                    return_seams=True
                )
                
                if result:
                    # result should be (image, seam_info) tuple when return_seams=True
                    if isinstance(result, tuple) and len(result) == 2:
                        self.current_image, self.last_seam_info = result
                    else:
                        # If not a tuple, just get the image
                        self.current_image = result
                        self.last_seam_info = {}
                    
                    # Get timing info
                    self.last_timing_info = self.last_seam_info.get('timing', {}) if self.last_seam_info else {}
                    
                    # Create seam visualizations if we have seam info
                    if self.last_seam_info and self.original_image is not None:
                        # Create seam carver instance using explicit class
                        seam_carver = None
                        visualizations = None
                        if self.last_algorithm_used is not None:
                            seam_carver = self._create_seam_carver(self.last_algorithm_used)
                        
                        # Call the method that returns a tuple of three images
                        if seam_carver is not None:
                            visualizations = seam_carver.create_seam_visualization(
                            self.original_image,
                            self.last_seam_info
                        )
                        
                        # Unpack and store the three visualization types
                        if visualizations is not None:
                            all_seams_img, removed_img, inserted_img = visualizations
                            self.last_seam_info['all_seams_image'] = all_seams_img
                            self.last_seam_info['removed_seams_image'] = removed_img
                            self.last_seam_info['inserted_seams_image'] = inserted_img
                else:
                    return False
            else:
                # Traditional resize
                self.current_image = cv.resize(self.current_image, (new_width, new_height), interpolation=cv.INTER_AREA)
                self.last_timing_info = {'algorithm': 0.0, 'total': 0.0, 'algorithm_name': 'Traditional'}
                self.last_seam_info = None
                self.last_algorithm_used = None
            
            return True
        except Exception as e:
            print(f"Error resizing image: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    def _create_seam_carver(self, algorithm: str) -> SeamCarver:
        """Helper method to create seam carver instances"""
        if algorithm == "Hubble 001":
            return SeamCarverHubble001()
        elif algorithm == "Hubble 002":
            return SeamCarverHubble002()
        else:
            raise ValueError(f"Unknown algorithm: {algorithm}")
    
    def get_seam_visualizations(self):
        """Get seam visualization images"""
        if self.last_seam_info and self.last_algorithm_used:
            return {
                'all': self.last_seam_info.get('all_seams_image'),
                'removed': self.last_seam_info.get('removed_seams_image'),
                'inserted': self.last_seam_info.get('inserted_seams_image')
            }
        return None
    
    def reset_to_original(self):
        """Reset to original image"""
        if self.original_image is not None:
            self.current_image = self.original_image.copy()
            self.last_timing_info = None
            self.last_seam_info = None
            self.last_algorithm_used = None
            return True
        return False
        
    def _seam_carving_resize(self, new_width, new_height, algorithm, progress_callback=None, return_seams=False):
        """Content-aware resizing using seam carving"""
        # Create seam carver instance
        seam_carver = self._create_seam_carver(algorithm)
        
        # Use the seam carver to resize the current image
        result = seam_carver.carve(
            img=self.current_image.copy(),
            target_width=new_width,
            target_height=new_height,
            progress_callback=progress_callback,
            return_seams=return_seams
        )
        
        return result
    
    def get_processed_image(self):
        """Get the current processed image with timing and seam info"""
        if self.current_image is not None:
            return self.current_image.copy(), self.last_timing_info, self.last_seam_info
        return None
    
    def save_image(self, save_path, img = None):
        """Save image to file"""
        if img is None:
            if self.current_image is None:
                return False
            img = self.current_image
        
        try:
            cv.imwrite(save_path, img)
            return True
        except Exception as e:
            print(f"Error saving image: {e}")
            return False

    def convert_cv_image(self, image=None, output_format="qpixmap"):
        """
        Convert OpenCV image to QImage or QPixmap
        
        Args:
            image: OpenCV image (if None, uses self.current_image)
            output_format: "qimage" or "qpixmap"
        
        Returns:
            QImage or QPixmap object, or empty object if conversion fails
        """
        if image is None:
            image = self.current_image
            
        if image is None:
            return QImage() if output_format.lower() == "qimage" else QPixmap()
        
        try:
            # Convert BGR to RGB for color images
            if len(image.shape) == 3 and image.shape[2] == 3:
                rgb_image = cv.cvtColor(image, cv.COLOR_BGR2RGB)
            else:
                rgb_image = image
            
            h, w = rgb_image.shape[:2]
            bytes_per_line = 3 * w if len(rgb_image.shape) == 3 else w
            
            # Create QImage
            if len(rgb_image.shape) == 3:
                q_img = QImage(rgb_image.data, w, h, bytes_per_line, QImage.Format_RGB888)
            else:
                q_img = QImage(rgb_image.data, w, h, bytes_per_line, QImage.Format_Grayscale8)
            
            # Return based on requested format
            if output_format.lower() == "qimage":
                return q_img
            else:  # qpixmap
                return QPixmap.fromImage(q_img)
                
        except Exception as e:
            print(f"Error converting image: {e}")
            return QImage() if output_format.lower() == "qimage" else QPixmap()



"""
utilities/seam_carving_algorithms.py
Modular seam carving implementations for content-aware image resizing
"""

import numpy as np
import cv2 as cv
import time
from typing import List, Callable, Optional, Tuple, Dict, Union
from abc import ABC, abstractmethod


class SeamCarver(ABC):
    """Abstract base class for seam carving algorithms"""
    
    def __init__(self, name: str = "Base"):
        """
        Initialize SeamCarver with algorithm name.
        
        Args:
            name: Algorithm name/identifier
        """
        self.name = name
        self.default_color_space = 'rgb'
        
    def calculate_energy(self, img: np.ndarray, color_space: str = None) -> np.ndarray:
        """
        Return energy map (gradient magnitude) for the given image.
        
        Args:
            img: Input image
            color_space: Override default color space. If None, uses algorithm default.
        """
        if color_space is None:
            color_space = self.default_color_space
            
        if color_space.lower() == 'rgb':
            gray = cv.cvtColor(img, cv.COLOR_RGB2GRAY)
        elif color_space.lower() == 'bgr':
            gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
        else:
            raise ValueError("color_space must be either 'rgb' or 'bgr'")
        
        grad_x = cv.Sobel(gray, cv.CV_64F, 1, 0, ksize=3)
        grad_y = cv.Sobel(gray, cv.CV_64F, 0, 1, ksize=3)
        energy = np.abs(grad_x) + np.abs(grad_y)
        return energy
    
    def _mark_seam_on_image(self, img: np.ndarray, seam: List[int], 
                           color: Tuple[int, int, int] = (0, 255, 0), 
                           thickness: int = 1) -> np.ndarray:
        """
        Mark a seam on the image with a colored line (for visualization only).
        
        Args:
            img: Input image (BGR format)
            seam: List of column indices for the seam (length = height)
            color: BGR color tuple for the seam (default: green)
            thickness: Thickness of the seam line
        
        Returns:
            Image with seam marked (BGR format)
        """
        marked_img = img.copy()
        h, w = img.shape[:2]
        
        for i in range(h):
            j = seam[i]
            # Draw a line for better visibility
            for offset in range(-thickness // 2, thickness // 2 + 1):
                col = j + offset
                if 0 <= col < w:
                    marked_img[i, col] = color
        return marked_img
    
    @abstractmethod
    def _find_vertical_seam(self, energy: np.ndarray) -> List[int]:
        """Find vertical seam using dynamic programming (to be implemented by subclasses)"""
        pass
    
    @abstractmethod
    def carve(self, img: np.ndarray, target_width: int, target_height: int | None = None, 
          progress_callback: Optional[Callable] = None,
          return_seams: bool = False) -> Union[np.ndarray, Tuple[np.ndarray, Dict]]:
        """Main seam carving function (to be implemented by subclasses)"""
        pass
    
    def create_seam_visualization(self, original_img: np.ndarray, seam_info: Dict, 
                          removed_color: Tuple[int, int, int] = (0, 0, 255),  # Red
                          inserted_color: Tuple[int, int, int] = (0, 255, 0),  # Green
                          thickness: int = 1) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        Create seam visualizations for removed and inserted seams.
        
        Args:
            original_img: Original image (BGR format)
            seam_info: Dictionary containing seam information
            removed_color: Color for removed seams (BGR)
            inserted_color: Color for inserted seams (BGR)
            thickness: Thickness of seam lines
        
        Returns:
            Tuple of (all_seams_image, removed_seams_image, inserted_seams_image)
            - all_seams_image: Shows ALL seams (both removed and inserted)
            - removed_seams_image: Shows only removed seams
            - inserted_seams_image: Shows only inserted seams
        """
        # Create copies for visualization
        all_seams_img = original_img.copy()
        removed_img = original_img.copy()
        inserted_img = original_img.copy()
        
        h, w = original_img.shape[:2]
        
        # Check if seam_info is valid
        if not seam_info or not isinstance(seam_info, dict):
            return all_seams_img, removed_img, inserted_img
        
        # Initialize default structure if missing
        if 'removed_seams' not in seam_info:
            seam_info['removed_seams'] = {'vertical': [], 'horizontal': []}
        if 'inserted_seams' not in seam_info:
            seam_info['inserted_seams'] = {'vertical': [], 'horizontal': []}
        
        # Helper function to mark a VERTICAL seam on an image
        def mark_vertical_seam(img, seam, color):
            """Mark a vertical seam on the image with the given color"""
            marked_img = img.copy()
            if not seam or len(seam) != h:  # Vertical seam must have h elements
                return marked_img
                
            for i in range(h):
                j = seam[i]
                if 0 <= j < w:  # Ensure column is within bounds
                    for offset in range(-thickness//2, thickness//2 + 1):
                        col = j + offset
                        if 0 <= col < w:
                            marked_img[i, col] = color
            return marked_img
        
        # Helper function to mark a HORIZONTAL seam on an image
        def mark_horizontal_seam(img, seam, color):
            """Mark a horizontal seam on the image with the given color"""
            marked_img = img.copy()
            if not seam:
                return marked_img
            
            h, w = img.shape[:2]
            
            # For a horizontal seam, we have one value for each column (width)
            # But the seam array stores row indices for each column
            if len(seam) != w:
                print(f"WARNING: Horizontal seam length mismatch: {len(seam)} != {w}")
                # Try to handle it anyway
                for j in range(min(len(seam), w)):
                    i = seam[j]
                    if 0 <= i < h:
                        for offset in range(-thickness//2, thickness//2 + 1):
                            row = i + offset
                            if 0 <= row < h:
                                marked_img[row, j] = color
            else:
                # Normal case
                for j in range(w):
                    i = seam[j]
                    if 0 <= i < h:
                        for offset in range(-thickness//2, thickness//2 + 1):
                            row = i + offset
                            if 0 <= row < h:
                                marked_img[row, j] = color
            return marked_img
        
        # DEBUG: Print seam information to understand the structure
        # print(f"DEBUG: Image dimensions: {h}x{w}")
        # print(f"DEBUG: Vertical removed seams: {len(seam_info['removed_seams'].get('vertical', []))}")
        # print(f"DEBUG: Vertical inserted seams: {len(seam_info['inserted_seams'].get('vertical', []))}")
        # print(f"DEBUG: Horizontal removed seams: {len(seam_info['removed_seams'].get('horizontal', []))}")
        # print(f"DEBUG: Horizontal inserted seams: {len(seam_info['inserted_seams'].get('horizontal', []))}")
        
        # Check and print example seam lengths
        if seam_info['removed_seams'].get('horizontal'):
            first_horiz_seam = seam_info['removed_seams']['horizontal'][0] if seam_info['removed_seams']['horizontal'] else None
            if first_horiz_seam is not None:
                print(f"DEBUG: First horizontal removed seam length: {len(first_horiz_seam)} (should be {w})")
        
        if seam_info['inserted_seams'].get('horizontal'):
            first_horiz_seam = seam_info['inserted_seams']['horizontal'][0] if seam_info['inserted_seams']['horizontal'] else None
            if first_horiz_seam is not None:
                print(f"DEBUG: First horizontal inserted seam length: {len(first_horiz_seam)} (should be {w})")
        
        # Mark ALL vertical seams on all images
        for seam in seam_info['removed_seams'].get('vertical', []):
            if seam and len(seam) == h:  # Validate seam length
                # Mark on removed image (red)
                removed_img = mark_vertical_seam(removed_img, seam, removed_color)
                # Mark on combined image (red)
                all_seams_img = mark_vertical_seam(all_seams_img, seam, removed_color)
        
        for seam in seam_info['inserted_seams'].get('vertical', []):
            if seam and len(seam) == h:  # Validate seam length
                # Mark on inserted image (green)
                inserted_img = mark_vertical_seam(inserted_img, seam, inserted_color)
                # Mark on combined image (green)
                all_seams_img = mark_vertical_seam(all_seams_img, seam, inserted_color)
        
        # Mark ALL horizontal seams on all images
        for seam in seam_info['removed_seams'].get('horizontal', []):
            if seam and len(seam) == w:  # Validate seam length (horizontal seams have w elements)
                # Mark on removed image (red)
                removed_img = mark_horizontal_seam(removed_img, seam, removed_color)
                # Mark on combined image (red)
                all_seams_img = mark_horizontal_seam(all_seams_img, seam, removed_color)
        
        for seam in seam_info['inserted_seams'].get('horizontal', []):
            if seam and len(seam) == w:  # Validate seam length (horizontal seams have w elements)
                # Mark on inserted image (green)
                inserted_img = mark_horizontal_seam(inserted_img, seam, inserted_color)
                # Mark on combined image (green)
                all_seams_img = mark_horizontal_seam(all_seams_img, seam, inserted_color)
        
        return all_seams_img, removed_img, inserted_img


class SeamCarverHubble001(SeamCarver):
    """Seam carving algorithm variant 001: Sequential seam processing"""
    
    def __init__(self):
        super().__init__("Hubble 001")
        self.default_color_space = 'rgb'
        self.use_absolute_backtrack = False
    
    def _find_vertical_seam(self, energy: np.ndarray) -> List[int]:
        """Hubble 001: Uses relative backtracking offsets"""
        h, w = energy.shape
        M = energy.copy().astype(np.float64)
        backtrack = np.zeros_like(M, dtype=np.int32)
        
        # Build cumulative energy matrix
        for i in range(1, h):
            for j in range(0, w):
                # Handle boundary cases
                left = M[i-1, j-1] if j > 0 else float('inf')
                middle = M[i-1, j]
                right = M[i-1, j+1] if j < w-1 else float('inf')
                
                # Find minimum energy path
                min_energy = min(left, middle, right)
                M[i, j] += min_energy
                
                # Store relative backtracking information
                if min_energy == left:
                    backtrack[i, j] = -1  # come from left
                elif min_energy == middle:
                    backtrack[i, j] = 0   # come from middle
                else:
                    backtrack[i, j] = 1   # come from right
        
        # Find the starting point of the seam
        seam = []
        j = np.argmin(M[-1])
        seam.append(j)
        
        # Backtrack to find the complete seam
        for i in range(h-1, 0, -1):
            j = j + backtrack[i, j]
            seam.append(j)
        
        return seam[::-1]  # reverse to go from top to bottom
    
    def _remove_vertical_seam(self, img: np.ndarray, seam: List[int]) -> np.ndarray:
        """Remove vertical seam from image"""
        h, w, c = img.shape
        new_img = np.zeros((h, w-1, c), dtype=img.dtype)
        
        for i in range(h):
            j = seam[i]
            new_img[i, :, :] = np.delete(img[i, :, :], j, axis=0)
        
        return new_img

    def _insert_vertical_seam(self, img: np.ndarray, seam: List[int]) -> np.ndarray:
        """
        Insert vertical seam by averaging with neighbors.
        Creates a natural-looking seam that blends with the image.
        
        Args:
            img: Input image (BGR format)
            seam: Seam to insert
        
        Returns:
            Image with seam inserted (blended naturally)
        """
        h, w, c = img.shape
        new_img = np.zeros((h, w + 1, c), dtype=img.dtype)
        
        for i in range(h):
            j = seam[i]
            
            # Copy all pixels before the seam position
            new_img[i, :j, :] = img[i, :j, :]
            
            # Create new pixel at seam position by averaging neighbors
            if j == 0:
                # Left edge case - average with right neighbor only
                new_pixel = (img[i, j, :].astype(np.float32) + img[i, j+1, :].astype(np.float32)) / 2
            elif j == w - 1:
                # Right edge case - average with left neighbor only  
                new_pixel = (img[i, j-1, :].astype(np.float32) + img[i, j, :].astype(np.float32)) / 2
            else:
                # General case - average left and right neighbors
                new_pixel = (img[i, j-1, :].astype(np.float32) + 
                            img[i, j, :].astype(np.float32) + 
                            img[i, j+1, :].astype(np.float32)) / 3
            
            # Insert the new pixel and copy the original
            new_img[i, j, :] = new_pixel.astype(img.dtype)
            new_img[i, j+1, :] = img[i, j, :]
            
            # Copy all pixels after the seam position (shifted by 1)
            new_img[i, j+2:, :] = img[i, j+1:, :]
        
        return new_img

    def _reduce_width(self, img: np.ndarray, num_seams: int, 
                     progress_callback: Optional[Callable] = None,
                     return_seams: bool = False) -> Tuple[np.ndarray, List[List[int]]]:
        """
        Reduce image width by removing vertical seams sequentially.
        
        Returns:
            Tuple of (carved_image, list_of_seams_removed)
        """
        current_img = img.copy()
        seams_removed = []
        
        for seam_num in range(num_seams):
            energy = self.calculate_energy(current_img)
            seam = self._find_vertical_seam(energy)
            seams_removed.append(seam)
            current_img = self._remove_vertical_seam(current_img, seam)

            if progress_callback:
                progress_callback(seam_num + 1)
        
        if return_seams:
            return current_img, seams_removed
        return current_img

    def _enlarge_width(self, img: np.ndarray, num_seams: int, 
                      progress_callback: Optional[Callable] = None,
                      return_seams: bool = False) -> Tuple[np.ndarray, List[List[int]]]:
        """
        Enlarge image width by inserting vertical seams sequentially.
        
        Returns:
            Tuple of (carved_image, list_of_seams_inserted)
        """
        current_img = img.copy()
        seams_inserted = []
        
        if progress_callback:
            progress_callback(0, num_seams * 2)
        
        # First, find all the seams we would remove (in order of importance)
        seams_to_duplicate = []
        temp_img = current_img.copy()
        
        for i in range(num_seams):
            energy = self.calculate_energy(temp_img)
            seam = self._find_vertical_seam(energy)
            seams_to_duplicate.append(seam)
            temp_img = self._remove_vertical_seam(temp_img, seam)

            if progress_callback:
                progress_callback(i + 1)
        
        # Now insert the seams in reverse order (least important first)
        for i, seam in enumerate(reversed(seams_to_duplicate)):
            seams_inserted.append(seam)
            current_img = self._insert_vertical_seam(current_img, seam)
            if progress_callback:
                progress_callback(num_seams + i + 1)
        
        if return_seams:
            return current_img, seams_inserted
        return current_img

    def carve(self, img: np.ndarray, target_width: int, target_height: int | None = None, 
              progress_callback: Optional[Callable] = None,
              return_seams: bool = False):
        """
        Main seam carving function to resize image with timing.
        
        Args:
            img: Input image (BGR format)
            target_width: Target width for output
            target_height: Target height for output (optional)
            progress_callback: Callback for progress updates
            return_seams: If True, returns both carved image and seam information
        
        Returns:
            If return_seams=True: (carved_image, seam_info_dict)
            If return_seams=False: carved_image only
        """
        start_time = time.time()
        
        if target_height is None:
            target_height = img.shape[0]

        # Initialize seam info
        seam_info = {
            'removed_seams': {'vertical': [], 'horizontal': []},
            'inserted_seams': {'vertical': [], 'horizontal': []},
            'timing': {}
        }

        # Start algorithm-specific timing
        algorithm_start = time.time()
        
        result = self._seam_carving_resize(
            img, target_width, target_height, progress_callback, 
            return_seams, seam_info
        )
        
        # Calculate timing
        algorithm_time = time.time() - algorithm_start
        total_time = time.time() - start_time
        
        seam_info['timing'] = {
            'algorithm': algorithm_time,
            'total': total_time,
            'algorithm_name': self.name
        }
        
        if return_seams:
            # Check if result is already a tuple (image, seam_info)
            if isinstance(result, tuple) and len(result) == 2:
                # Unpack and update seam_info
                carved_img, existing_seam_info = result
                # Merge timing info into existing seam_info
                existing_seam_info['timing'] = seam_info['timing']
                return carved_img, existing_seam_info
            else:
                # Just return result with our seam_info
                return result, seam_info
        else:
            # If result is a tuple, extract just the image
            if isinstance(result, tuple) and len(result) == 2:
                return result[0]  # Return just the image
            else:
                return result  # Return the image directly
    
    def _seam_carving_resize(self, img: np.ndarray, new_width: int, new_height: int, 
                             progress_callback: Optional[Callable] = None,
                             return_seams: bool = False,
                             seam_info: Dict = None):
        """Sequential seam carving with seam tracking"""
        current_img = img.copy()
        
        # Calculate differences
        width_diff = current_img.shape[1] - new_width
        height_diff = current_img.shape[0] - new_height
        
        # Initialize seam info
        if seam_info is None:
            seam_info = {
                'removed_seams': {'vertical': [], 'horizontal': []},
                'inserted_seams': {'vertical': [], 'horizontal': []}
            }
        
        # Handle width adjustment
        if width_diff != 0:
            if width_diff > 0:
                # Width reduction
                current_img, removed_seams = self._reduce_width(
                    current_img, width_diff, progress_callback, return_seams=True
                )
                seam_info['removed_seams']['vertical'] = removed_seams
            else:
                # Width enlargement
                current_img, inserted_seams = self._enlarge_width(
                    current_img, abs(width_diff), progress_callback, return_seams=True
                )
                seam_info['inserted_seams']['vertical'] = inserted_seams
        
        # Handle height adjustment
        if height_diff != 0:
            if height_diff > 0:
                # Height reduction (rotate to work with horizontal seams)
                rotated_img = np.rot90(current_img, 1)
                rotated_img, removed_seams = self._reduce_width(
                    rotated_img, height_diff, progress_callback, return_seams=True
                )
                current_img = np.rot90(rotated_img, 3)
                seam_info['removed_seams']['horizontal'] = removed_seams
            else:
                # Height enlargement
                rotated_img = np.rot90(current_img, 1)
                rotated_img, inserted_seams = self._enlarge_width(
                    rotated_img, abs(height_diff), progress_callback, return_seams=True
                )
                current_img = np.rot90(rotated_img, 3)
                seam_info['inserted_seams']['horizontal'] = inserted_seams
        
        if return_seams:
            return current_img, seam_info
        return current_img


class SeamCarverHubble002(SeamCarver):
    """Seam carving algorithm variant 002: Bulk seam processing"""
    
    def __init__(self):
        super().__init__("Hubble 002")
        self.default_color_space = 'bgr'
        self.use_absolute_backtrack = True
    
    def _find_vertical_seam(self, energy: np.ndarray) -> List[int]:
        """Hubble 002: Uses absolute backtracking indices"""
        h, w = energy.shape
        M = energy.copy().astype(np.float64)
        backtrack = np.zeros_like(M, dtype=np.int32)

        # Build cumulative energy matrix
        for i in range(1, h):
            for j in range(w):
                left = M[i - 1, j - 1] if j - 1 >= 0 else np.inf
                middle = M[i - 1, j]
                right = M[i - 1, j + 1] if j + 1 < w else np.inf

                min_prev = min(left, middle, right)
                M[i, j] += min_prev

                # Store absolute backtracking information
                if min_prev == left:
                    backtrack[i, j] = j - 1
                elif min_prev == middle:
                    backtrack[i, j] = j
                else:
                    backtrack[i, j] = j + 1

        # Find position of smallest element in last row
        seam = [0] * h
        j = int(np.argmin(M[-1]))
        seam[-1] = j
        for i in range(h - 1, 0, -1):
            j = int(backtrack[i, j])
            seam[i - 1] = j
        return seam
    
    def _remove_multiple_seams_bulk(self, img: np.ndarray, seams_original: List[List[int]]) -> np.ndarray:
        """
        Remove multiple seams from the ORIGINAL image in one synchronized pass.
        """
        h, w, _ = img.shape
        result_rows = []

        for i in range(h):
            cols_to_remove = {seam[i] for seam in seams_original}
            keep_cols = [col for col in range(w) if col not in cols_to_remove]
            new_row = img[i, keep_cols, :]
            result_rows.append(new_row)

        new_img = np.stack(result_rows, axis=0)
        return new_img

    def _insert_vertical_seam_bulk(self, img: np.ndarray, seam: List[int]) -> np.ndarray:
        """Insert a single vertical seam into img with blending."""
        h, w, c = img.shape
        new_img = np.zeros((h, w + 1, c), dtype=img.dtype)

        for i in range(h):
            j = seam[i]
            if j > 0:
                new_img[i, :j, :] = img[i, :j, :]
            
            # Create blended pixel at seam position
            if j == 0:
                # Left edge case
                new_pixel = (img[i, j, :].astype(np.float32) + img[i, j+1, :].astype(np.float32)) / 2
            elif j == w - 1:
                # Right edge case
                new_pixel = (img[i, j-1, :].astype(np.float32) + img[i, j, :].astype(np.float32)) / 2
            else:
                # General case - average neighbors
                new_pixel = (img[i, j-1, :].astype(np.float32) + 
                            img[i, j, :].astype(np.float32) + 
                            img[i, j+1, :].astype(np.float32)) / 3
            
            new_img[i, j, :] = new_pixel.astype(img.dtype)
            new_img[i, j + 1, :] = img[i, j, :]
            
            if j + 1 < w:
                new_img[i, j + 2:, :] = img[i, j + 1:, :]

        return new_img
    
    def carve(self, img: np.ndarray, target_width: int, target_height: int | None = None, 
              progress_callback: Optional[Callable] = None,
              return_seams: bool = False):
        """
        Main seam carving function to resize image with timing.
        
        Args:
            img: Input image (BGR format)
            target_width: Target width for output
            target_height: Target height for output (optional)
            progress_callback: Callback for progress updates
            return_seams: If True, returns both carved image and seam information
        
        Returns:
            If return_seams=True: (carved_image, seam_info_dict)
            If return_seams=False: carved_image only
        """
        start_time = time.time()
        
        if target_height is None:
            target_height = img.shape[0]

        # Initialize seam info
        seam_info = {
            'removed_seams': {'vertical': [], 'horizontal': []},
            'inserted_seams': {'vertical': [], 'horizontal': []},
            'timing': {}
        }

        # Start algorithm-specific timing
        algorithm_start = time.time()
        
        result = self._seam_carving_resize(
            img, target_width, target_height, progress_callback, 
            return_seams, seam_info
        )
        
        # Calculate timing
        algorithm_time = time.time() - algorithm_start
        total_time = time.time() - start_time
        
        seam_info['timing'] = {
            'algorithm': algorithm_time,
            'total': total_time,
            'algorithm_name': self.name
        }
        
        if return_seams:
            # Check if result is already a tuple (image, seam_info)
            if isinstance(result, tuple) and len(result) == 2:
                # Unpack and update seam_info
                carved_img, existing_seam_info = result
                # Merge timing info into existing seam_info
                existing_seam_info['timing'] = seam_info['timing']
                return carved_img, existing_seam_info
            else:
                # Just return result with our seam_info
                return result, seam_info
        else:
            # If result is a tuple, extract just the image
            if isinstance(result, tuple) and len(result) == 2:
                return result[0]  # Return just the image
            else:
                return result  # Return the image directly
    
    def _seam_carving_resize(self, img: np.ndarray, new_width: int, new_height: int,
                             progress_callback: Optional[Callable] = None,
                             return_seams: bool = False,
                             seam_info: Dict = None):
        """
        Bulk seam carving implementation.
        """
        h, w, _ = img.shape
        width_diff = w - new_width
        height_diff = h - new_height

        if width_diff == 0 and height_diff == 0:
            if return_seams:
                return img, seam_info
            return img

        # Initialize seam info
        if seam_info is None:
            seam_info = {
                'removed_seams': {'vertical': [], 'horizontal': []},
                'inserted_seams': {'vertical': [], 'horizontal': []}
            }

        # Store original dimensions for seam tracking
        orig_h, orig_w = h, w

        # Helper progress updater
        def _progress(step, total=None):
            if progress_callback:
                try:
                    if total is None:
                        progress_callback(step)
                    else:
                        progress_callback(step, total)
                except Exception:
                    pass

        current_img = img.copy()
        
        # Handle width adjustment
        if width_diff != 0:
            if width_diff > 0:
                # Need to reduce width by k seams
                k = int(width_diff)
                temp_img = current_img.copy()
                idx_map = np.tile(np.arange(w), (h, 1))

                seams_original = []  # store seams as original column indices
                for s in range(k):
                    energy = self.calculate_energy(temp_img)
                    seam = self._find_vertical_seam(energy)  # seam indices for temp_img
                    seam_original = [int(idx_map[i, seam[i]]) for i in range(h)]
                    seams_original.append(seam_original)
                    
                    # Update temp image and index map
                    new_temp_rows = []
                    new_idx_rows = []
                    for i in range(h):
                        new_temp_rows.append(np.delete(temp_img[i, :, :], seam[i], axis=0))
                        new_idx_rows.append(np.delete(idx_map[i, :], seam[i], axis=0))
                    temp_img = np.stack(new_temp_rows, axis=0)
                    idx_map = np.stack(new_idx_rows, axis=0)

                    _progress(s + 1, k)
                
                # Remove all seams at once
                current_img = self._remove_multiple_seams_bulk(current_img, seams_original)
                seam_info['removed_seams']['vertical'] = seams_original
                
                _progress(k, k)
            else:
                # Width enlargement
                k = int(-width_diff)
                temp_img = current_img.copy()
                idx_map = np.tile(np.arange(w), (h, 1))
                seams_original = []
                for s in range(k):
                    energy = self.calculate_energy(temp_img)
                    seam = self._find_vertical_seam(energy)
                    seam_original = [int(idx_map[i, seam[i]]) for i in range(h)]
                    seams_original.append(seam_original)
                    
                    new_temp_rows = []
                    new_idx_rows = []
                    for i in range(h):
                        new_temp_rows.append(np.delete(temp_img[i, :, :], seam[i], axis=0))
                        new_idx_rows.append(np.delete(idx_map[i, :], seam[i], axis=0))
                    temp_img = np.stack(new_temp_rows, axis=0)
                    idx_map = np.stack(new_idx_rows, axis=0)
                    _progress(s + 1, k)
                
                # Insert seams one by one (with blending)
                for s_idx, seam_orig in enumerate(seams_original):
                    seam_current = []
                    for i in range(h):
                        inserts_before = 0
                        for prev in seams_original[:s_idx]:
                            if prev[i] <= seam_orig[i]:
                                inserts_before += 1
                        current_pos = seam_orig[i] + inserts_before
                        # Clamp to valid range
                        current_pos = max(0, min(current_img.shape[1] - 1, current_pos))
                        seam_current.append(current_pos)

                    current_img = self._insert_vertical_seam_bulk(current_img, seam_current)
                    _progress(s_idx + 1, k)

                seam_info['inserted_seams']['vertical'] = seams_original

        # Handle height adjustment (rotate for horizontal seams)
        if height_diff != 0:
            # Rotate to work with horizontal seams
            rotated_img = np.rot90(current_img, 1)
            
            # Call recursively - pass None for seam_info to get new one for rotated space
            if return_seams:
                rotated_result, rotated_seam_info = self._seam_carving_resize(
                    rotated_img, new_height, new_width, progress_callback, 
                    return_seams, None  # Create new seam info for rotated space
                )
                
                # Convert rotated seams back to original orientation
                # Rotated vertical seams are horizontal in original, and vice versa
                for seam in rotated_seam_info['removed_seams']['vertical']:
                    # This seam was vertical in rotated space = horizontal in original
                    seam_info['removed_seams']['horizontal'].append(seam)
                    
                for seam in rotated_seam_info['inserted_seams']['vertical']:
                    # This seam was vertical in rotated space = horizontal in original
                    seam_info['inserted_seams']['horizontal'].append(seam)
                    
                # Note: In rotated space, we only track vertical seams since we rotate
                # to convert horizontal to vertical
            else:
                rotated_result = self._seam_carving_resize(
                    rotated_img, new_height, new_width, progress_callback, 
                    return_seams, None
                )
            
            current_img = np.rot90(rotated_result, 3)

        if return_seams:
            return current_img, seam_info
        return current_img

